

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Code your own polarizability tensor workflow, part 2 &mdash; My_BigDFT  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Solution" href="Solution_03.html" />
    <link rel="prev" title="Exercise 3" href="../exercise_03.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> My_BigDFT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../code_doc.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">MyBigDFT tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exercises.html">Exercises</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../exercise_01.html">Exercise 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../exercise_02.html">Exercise 2</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../exercise_03.html">Exercise 3</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Code your own polarizability tensor workflow, part 2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#The-AbstractWorkflow-class">The AbstractWorkflow class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Create-a-class">Create a class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Use-that-class!">Use that class!</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Improve-that-class!">Improve that class!</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Solution_03.html">Solution</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">My_BigDFT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exercises.html">Exercises</a> &raquo;</li>
        
          <li><a href="../exercise_03.html">Exercise 3</a> &raquo;</li>
        
      <li>Code your own polarizability tensor workflow, part 2</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/notebooks/Exercise_03_Polarizability_Tensor_Workflow_2.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput,
div.nbinput div.prompt,
div.nbinput div.input_area,
div.nbinput div[class*=highlight],
div.nbinput div[class*=highlight] pre,
div.nboutput,
div.nbinput div.prompt,
div.nbinput div.output_area,
div.nboutput div[class*=highlight],
div.nboutput div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput,
div.nboutput {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput,
    div.nboutput {
        flex-direction: column;
    }
}

/* input container */
div.nbinput {
    padding-top: 5px;
}

/* last container */
div.nblast {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput div.prompt,
div.nboutput div.prompt {
    min-width: 5ex;
    padding-top: 0.4em;
    padding-right: 0.4em;
    text-align: right;
    flex: 0;
}
@media (max-width: 540px) {
    div.nbinput div.prompt,
    div.nboutput div.prompt {
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput div.prompt.empty {
        padding: 0;
    }
}

/* disable scrollbars on prompts */
div.nbinput div.prompt pre,
div.nboutput div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput div.input_area,
div.nboutput div.output_area {
    padding: 0.4em;
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput div.input_area,
    div.nboutput div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    background: #f5f5f5;
}

/* override MathJax center alignment in output cells */
div.nboutput div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput div.math p {
    text-align: left;
}

/* standard error */
div.nboutput div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="Code-your-own-polarizability-tensor-workflow,-part-2">
<h1>Code your own polarizability tensor workflow, part 2<a class="headerlink" href="#Code-your-own-polarizability-tensor-workflow,-part-2" title="Permalink to this headline">¶</a></h1>
<p>The main goal of this notebook is to show how the code implemented in the previous exercise can be easily converted to a fully functional class deriving from the <code class="docutils literal notranslate"><span class="pre">AbstractWorkflow</span></code> class.</p>
<p>We will stick to the polarizability tensor problem, in order to build on what was achieved in the previous exercises. The structure of this notebook is very similar to the previous ones. You can use the same resources to help you (especially the), while the solution to this exercise can be found <a class="reference external" href="https://mmoriniere.gitlab.io/MyBigDFT/notebooks/Solution_03.html">here</a>.</p>
<div class="section" id="The-AbstractWorkflow-class">
<h2>The <a class="reference external" href="https://mmoriniere.gitlab.io/MyBigDFT/workflow.html#mybigdft.workflows.workflow.AbstractWorkflow">AbstractWorkflow</a> class<a class="headerlink" href="#The-AbstractWorkflow-class" title="Permalink to this headline">¶</a></h2>
<p>You already saw that using the <code class="docutils literal notranslate"><span class="pre">Workflow</span></code> class allows to get a clean separation of the procedure to compute a quantity of interest:</p>
<ul class="simple">
<li><p>first, the definition of the jobs to be run,</p></li>
<li><p>then the jobs are run,</p></li>
<li><p>and finally, the desired output can be computed from the results of the calculations.</p></li>
</ul>
<p>The goal of the <code class="docutils literal notranslate"><span class="pre">AbstractWorkflow</span></code> class is to ease the implementation of this type of workflow in a class that is meant to be general, <em>i.e.</em>, that can be applicable to a large class of systems, using a large set of possible input parameters. Such a class is meant to be used simply by:</p>
<ul class="simple">
<li><p>initializing an instance of the class, setting the queue of jobs automatically,</p></li>
<li><p>running all the jobs of the workflow instance and performing the post-processing, all these actions being done by applying the <code class="docutils literal notranslate"><span class="pre">run</span></code> method.</p></li>
</ul>
<p>And that’s it!</p>
<p>Note that the post-processing procedure, which is defined in the class body, is automatically performed after all the jobs in the workflow queue. The quantities of interest (here, the polarizability tensor) are even used to set semi-private attributes, so that they can be easily accessed afterwards (don’t worry, the last sentence should get clearer by the end of the notebook).</p>
<p>Another interest of writing a class is that it enables you to add more functionalities to your class afterwards, such as adding another quantity to compute while running the post-processing procedure. Such changes would be readily available in your scripts or notebooks where you used that class: no need to modify those files one by one to make that functionality available there.</p>
<p>To write such a class you will need to:</p>
<ul class="simple">
<li><p>define which are the quantities to be computed while post-processing the results by:</p>
<ul>
<li><p>setting the value of the <code class="docutils literal notranslate"><span class="pre">POST_PROCESSING_ATTRIBUTES</span></code> list, containing the names of all the quantities of interest computed while post-processing,</p></li>
<li><p>defining a property getter for each of these attributes, so as to access them afterwards,</p></li>
</ul>
</li>
<li><p>override the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, in order to make sure than the queue of jobs is correctly initialized,</p></li>
<li><p>define the <code class="docutils literal notranslate"><span class="pre">post_proc</span></code> method to compute and then set the values of the quantities of interest.</p></li>
</ul>
</div>
<div class="section" id="Create-a-class">
<h2>Create a class<a class="headerlink" href="#Create-a-class" title="Permalink to this headline">¶</a></h2>
<p>The use of the <code class="docutils literal notranslate"><span class="pre">Workflow</span></code> class in the previous notebook showed you that having a clear separation of the initialization and post-processing of a workflow is important, notably to reduce the amount of code to copy and paste each time you want to change the system or the input parameters. We will go even further in that direction by writing a class deriving from the <code class="docutils literal notranslate"><span class="pre">AbstractWorkflow</span></code> class. You will see that the code you implemented in the previous exercise can be quickly adapted to meet our
needs here.</p>
<p>Part of the body of the class is already written, you must only code the following:</p>
<ul class="simple">
<li><p>add the string <code class="docutils literal notranslate"><span class="pre">&quot;pol_tensor&quot;</span></code> to the POST_PROCESSING_ATTRIBUTES list,</p></li>
<li><p>initialize the queue of jobs in the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method,</p></li>
<li><p>define the <code class="docutils literal notranslate"><span class="pre">post_proc</span></code> method to compute the value of the <code class="docutils literal notranslate"><span class="pre">pol_tensor</span></code> attribute.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method has <code class="docutils literal notranslate"><span class="pre">ground_state</span></code> as argument, which is meant to be a <code class="docutils literal notranslate"><span class="pre">Job</span></code> instance of the reference ground state. This job must be the first one in the queue. The three other jobs must be added by taking this one job as reference, only modifying the run directory (in the same manner as in the previous exercise) and the input parameters, so as to apply an electric field in each direction (<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>). To that end, you must add an optional argument
<code class="docutils literal notranslate"><span class="pre">ef_amplitude</span></code> to the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method to state the value of the electric field amplitude to be used in all the jobs (default value: <code class="docutils literal notranslate"><span class="pre">1.e-4</span></code>).</p>
<p>The definition of the <code class="docutils literal notranslate"><span class="pre">pol_tensor</span></code> method is given so as to give you an example of how to actually code such methods. Note the use of a <code class="docutils literal notranslate"><span class="pre">_poltensor</span></code> attribute in that method and in the <code class="docutils literal notranslate"><span class="pre">post_proc</span></code> method; this is what we meant by “semi-private attributes” in the previous section: defining a property returning such a semi-private attribute ensures that you can access the <code class="docutils literal notranslate"><span class="pre">pol_tensor</span></code> attribute here, but it cannot be set. The only way of modifying the value of this attribute is to change
the value of the <code class="docutils literal notranslate"><span class="pre">_poltensor</span></code>. This is actually what is done in the <code class="docutils literal notranslate"><span class="pre">post_proc</span></code> method!</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># Do not forget to import some relevant stuff...</span>
<span class="kn">from</span> <span class="nn">mybigdft.workflows.workflow</span> <span class="k">import</span> <span class="n">AbstractWorkflow</span>

<span class="k">class</span> <span class="nc">PolTensor</span><span class="p">(</span><span class="n">AbstractWorkflow</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This workflow allows to compute the (electronic) polarizability</span>
<span class="sd">    tensor of a given system.</span>

<span class="sd">    The polarizability tensor represents the response of the charges of</span>
<span class="sd">    a system (its dipole) to the application of an external electric</span>
<span class="sd">    field.</span>

<span class="sd">    To compute this polarizability tensor, some BigDFT calculations are</span>
<span class="sd">    performed, where the system is subject to an external electric</span>
<span class="sd">    field along each direction of space (:math:`x`, :math:`y` and</span>
<span class="sd">    :math:`z`). The elements of the polarizability tensor are then</span>
<span class="sd">    defined by the ratio of the delta of the dipole in one direction and</span>
<span class="sd">    the delta of the electric field amplitudes:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \alpha_{ij} = \frac{\Delta D_i}{\Delta E_j}</span>

<span class="sd">    where :math:`i, j \in \{x, y, z\}`, :math:`\Delta D_i` is the</span>
<span class="sd">    variation of the dipole along the :math:`i` direction and</span>
<span class="sd">    :math:`\Delta E_j` is the variation of the electric field amplitude</span>
<span class="sd">    along the :math:`j` direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Add &quot;pol_tensor&quot; to the list</span>
    <span class="n">POST_PROCESSING_ATTRIBUTES</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Add ef_amplitude optional argument (default value: 1.e-4)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ground_state</span><span class="p">,</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A PolTensor workflow is initialized by the job of the</span>
<span class="sd">        ground-state of the system and an electric field amplitude.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ground_state: Job</span>
<span class="sd">            Reference job, specifying the base input parameters (where no</span>
<span class="sd">            electric field is applied), the geometry of the system and the</span>
<span class="sd">            base run directory of the calculations.</span>
<span class="sd">        ef_amplitude: float</span>
<span class="sd">            Electric field amplitude to be applied along each direction,</span>
<span class="sd">            in atomic units (default to 1.e-4).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ground_state</span> <span class="o">=</span> <span class="n">ground_state</span>
        <span class="c1"># Set the queue of jobs thanks to ground_state and ef_amplitude</span>
        <span class="n">pt_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># This calls the __init__ method of the AbstractWorkflow class to</span>
        <span class="c1"># set the queue, the run method (that calls the post_proc method</span>
        <span class="c1"># automatically) and the default value of the post-processing</span>
        <span class="c1"># attributes to None.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="n">pt_queue</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ground_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set ground_state as a semi-private attribute: it can be accessed,</span>
<span class="sd">        but it cannot be set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Job</span>
<span class="sd">            Reference job, where no electric field is applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ground_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pol_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set pol_tensor as a semi-private attribute: it can be accessed,</span>
<span class="sd">        but it cannot be set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array of shape (3, 3)</span>
<span class="sd">            Polarizability tensor of the system, using :attr:`ground_state`</span>
<span class="sd">            as a reference job.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pol_tensor</span>

    <span class="k">def</span> <span class="nf">post_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute and set the polarizability tensor of the system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pol_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Compute the polarizability tensor thanks to the jobs in the queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pol_tensor</span> <span class="o">=</span> <span class="n">pol_tensor</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Let us test that class with for the N2 molecule</span>
<span class="kn">from</span> <span class="nn">mybigdft</span> <span class="k">import</span> <span class="n">Job</span><span class="p">,</span> <span class="n">Posinp</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">InputParams</span>
<span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0935</span><span class="p">])]</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">Posinp</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;angstroem&quot;</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="o">=</span><span class="s2">&quot;free&quot;</span><span class="p">)</span>
<span class="n">inp</span> <span class="o">=</span> <span class="n">InputParams</span><span class="p">({</span><span class="s2">&quot;dft&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;rmult&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="s2">&quot;hgrids&quot;</span><span class="p">:</span> <span class="mf">0.35</span><span class="p">}})</span>

<span class="c1"># 1- Using non-default electric field amplitude:</span>
<span class="n">gs_1</span> <span class="o">=</span> <span class="n">Job</span><span class="p">(</span><span class="n">posinp</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">inputparams</span><span class="o">=</span><span class="n">inp</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;N2&quot;</span><span class="p">,</span>
           <span class="n">run_dir</span><span class="o">=</span><span class="s2">&quot;N2/pol_tensor/non_default/&quot;</span><span class="p">)</span>
<span class="n">pt_wf_1</span> <span class="o">=</span> <span class="n">PolTensor</span><span class="p">(</span><span class="n">gs_1</span><span class="p">,</span> <span class="n">ef_amplitude</span><span class="o">=</span><span class="mf">5.e-4</span><span class="p">)</span>
<span class="c1">#   - correct electric field</span>
<span class="n">expected_efs_1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="mf">5.e-4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">5.e-4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">5.e-4</span><span class="p">]]</span>
<span class="k">for</span> <span class="n">job</span><span class="p">,</span> <span class="n">ef</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pt_wf_1</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">expected_efs_1</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">job</span><span class="o">.</span><span class="n">inputparams</span><span class="p">[</span><span class="s2">&quot;dft&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;elecfield&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ef</span>
<span class="c1">#   - correct run directories</span>
<span class="n">expected_run_dirs_1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;non_default/&quot;</span><span class="p">,</span> <span class="s2">&quot;non_default/EF_along_x+&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;non_default/EF_along_y+&quot;</span><span class="p">,</span> <span class="s2">&quot;non_default/EF_along_z+&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">job</span><span class="p">,</span> <span class="n">run_dir</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pt_wf_1</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">expected_run_dirs_1</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">job</span><span class="o">.</span><span class="n">run_dir</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">run_dir</span><span class="p">)</span>
<span class="c1">#   - correct pol_tensor attribute</span>
<span class="k">assert</span> <span class="n">pt_wf_1</span><span class="o">.</span><span class="n">pol_tensor</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">pt_wf_1</span><span class="o">.</span><span class="n">pol_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;&quot;AttributeError(&quot;can&#39;t set attribute&quot;,)&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Correct error catched!&quot;</span><span class="p">)</span>

<span class="c1"># 2- Using default electric field amplitude:</span>
<span class="n">gs_2</span> <span class="o">=</span> <span class="n">Job</span><span class="p">(</span><span class="n">posinp</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">inputparams</span><span class="o">=</span><span class="n">inp</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;N2&quot;</span><span class="p">,</span>
           <span class="n">run_dir</span><span class="o">=</span><span class="s2">&quot;N2/pol_tensor/default/&quot;</span><span class="p">)</span>
<span class="n">pt_wf_2</span> <span class="o">=</span> <span class="n">PolTensor</span><span class="p">(</span><span class="n">gs_2</span><span class="p">)</span>
<span class="c1">#   - correct electric field</span>
<span class="n">expected_efs_2</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.e-4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.e-4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.e-4</span><span class="p">]]</span>
<span class="k">for</span> <span class="n">job</span><span class="p">,</span> <span class="n">ef</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pt_wf_2</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">expected_efs_2</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">job</span><span class="o">.</span><span class="n">inputparams</span><span class="p">[</span><span class="s2">&quot;dft&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;elecfield&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ef</span>
<span class="c1">#   - correct run directories</span>
<span class="n">expected_run_dirs_2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;default/&quot;</span><span class="p">,</span> <span class="s2">&quot;default/EF_along_x+&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;default/EF_along_y+&quot;</span><span class="p">,</span> <span class="s2">&quot;default/EF_along_z+&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">job</span><span class="p">,</span> <span class="n">run_dir</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pt_wf_2</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">expected_run_dirs_2</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">job</span><span class="o">.</span><span class="n">run_dir</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">run_dir</span><span class="p">)</span>
<span class="c1">#   - correct pol_tensor attribute</span>
<span class="k">assert</span> <span class="n">pt_wf_2</span><span class="o">.</span><span class="n">pol_tensor</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">pt_wf_2</span><span class="o">.</span><span class="n">pol_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;&quot;AttributeError(&quot;can&#39;t set attribute&quot;,)&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Correct error catched!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Use-that-class!">
<h2>Use that class!<a class="headerlink" href="#Use-that-class!" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">PolTensor</span></code> class now being implemented, you can use it in order to (effortlessly) study some problems. Given the implementation of that class, you can solve some problems in the most concise manner, especially compared to what was possible if you were to use the schemes presented in the previous notebooks.</p>
<ul>
<li><p class="rubric" id="the-polarizability-tensor-must-not-depend-on-the-rotation-of-the-initial-molecule">The polarizability tensor must not depend on the rotation of the initial molecule</p>
</li>
</ul>
<p>The atoms of the molecule here lie along the <span class="math notranslate nohighlight">\(z\)</span> axis and the results should not change if the atoms lie along the <span class="math notranslate nohighlight">\(x\)</span> or <span class="math notranslate nohighlight">\(y\)</span> axis, for instance. Use the default electric field amplitude.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Compute the polarizability tensor when the molecule is along the x axis</span>
<span class="n">atoms_x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">pos_x</span> <span class="o">=</span> <span class="n">Posinp</span><span class="p">(</span><span class="n">atoms_x</span><span class="p">,</span> <span class="p">)</span>
<span class="n">run_dir_x</span> <span class="o">=</span> <span class="s2">&quot;N2/pol_tensor/atoms_along_x/&quot;</span>
<span class="n">pt_wf_x</span> <span class="o">=</span>
<span class="n">pt_wf_x</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c1"># Compute the polarizability tensor when the molecule is along the x axis</span>
<span class="n">atoms_y</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">pos_y</span> <span class="o">=</span> <span class="n">Posinp</span><span class="p">(</span><span class="n">atoms_y</span><span class="p">,</span> <span class="p">)</span>
<span class="n">run_dir_y</span> <span class="o">=</span> <span class="s2">&quot;N2/pol_tensor/atoms_along_y/&quot;</span>
<span class="n">pt_wf_y</span> <span class="o">=</span>
<span class="n">pt_wf_y</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Let us ensure that you obtained the expected results:</span>
<span class="c1"># - both tensors are the same</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">pt_wf_x</span><span class="o">.</span><span class="n">pol_tensor</span><span class="p">,</span> <span class="n">pt_wf_y</span><span class="o">.</span><span class="n">pol_tensor</span><span class="p">)</span>
<span class="c1"># - they have the same trace as the polarizability tensor where the molecule</span>
<span class="c1">#   is along the z axis</span>
<span class="n">gs_z</span> <span class="o">=</span> <span class="n">Job</span><span class="p">(</span><span class="n">posinp</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">inputparams</span><span class="o">=</span><span class="n">inp</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;N2&quot;</span><span class="p">,</span> <span class="n">run_dir</span><span class="o">=</span><span class="s2">&quot;N2/pol_tensor/&quot;</span><span class="p">)</span>
<span class="n">pt_wf_z</span> <span class="o">=</span> <span class="n">PolTensor</span><span class="p">(</span><span class="n">gs_z</span><span class="p">)</span>
<span class="n">pt_wf_z</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pt_wf_z</span><span class="o">.</span><span class="n">pol_tensor</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">pt_wf_x</span><span class="o">.</span><span class="n">pol_tensor</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">pt_wf_z</span><span class="o">.</span><span class="n">pol_tensor</span><span class="p">))</span>
</pre></div>
</div>
</div>
<ul>
<li><p class="rubric" id="what-is-the-influence-of-the-electric-field-amplitude-on-the-results">What is the influence of the electric field amplitude on the results?</p>
</li>
</ul>
<p>Compute the polarizability tensor of the N<span class="math notranslate nohighlight">\(_2\)</span> molecule using various electric field amplitudes and comment on how this affects the value of polarizability tensor.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">ef_amplitudes</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.e-11</span><span class="p">,</span> <span class="mf">1.e-10</span><span class="p">,</span> <span class="mf">1.e-9</span><span class="p">,</span> <span class="mf">1.e-8</span><span class="p">,</span> <span class="mf">1.e-7</span><span class="p">,</span> <span class="mf">1.e-6</span><span class="p">,</span> <span class="mf">1.e-5</span><span class="p">,</span> <span class="mf">1.e-4</span><span class="p">,</span> <span class="mf">1.e-3</span><span class="p">,</span> <span class="mf">1.e-2</span><span class="p">,</span> <span class="mf">1.e-1</span><span class="p">]</span>
<span class="c1"># Loop over the electric field amplitudes to compute various</span>
<span class="c1"># polarizability tensors</span>

</pre></div>
</div>
</div>
<ul>
<li><p class="rubric" id="how-does-the-polarizability-tensor-depend-on-the-system-geometry">How does the polarizability tensor depend on the system geometry?</p>
</li>
</ul>
<p>Modify the structure of the system by varying the distance between both atoms and comment on how this affects the value of polarizability tensor. Use the default electric field amplitude and the same base input parameters.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0735</span><span class="p">,</span> <span class="mf">1.0835</span><span class="p">,</span> <span class="mf">1.0935</span><span class="p">,</span> <span class="mf">1.1035</span><span class="p">,</span> <span class="mf">1.1135</span><span class="p">]</span>
<span class="c1"># Loop over the interatomic distances to compute various</span>
<span class="c1"># polarizability tensors</span>

</pre></div>
</div>
</div>
</div>
<div class="section" id="Improve-that-class!">
<h2>Improve that class!<a class="headerlink" href="#Improve-that-class!" title="Permalink to this headline">¶</a></h2>
<p>Another interest of defining a class is that you can easily improve it. You then only have to implement minor changes to your already performed scripts or notebooks to see those changes.</p>
<p>For instance, you often find the mean polarizability in the literature instead of the tensor itself. It is defined as the mean value of the polarizability tensor diagonal elements. Given that you already compute that tensor in the post-processing procedure, the addition of another post-processing attribute named <code class="docutils literal notranslate"><span class="pre">mean_polarizability</span></code> seems like a good idea.</p>
<ul>
<li><p class="rubric" id="add-the-mean-polarizability-post-processing-attribute">Add the mean polarizability post-processing attribute</p>
</li>
</ul>
<p>The goal here is to compute the mean polarizability while post-processing the calculations and make it available via an attribute. You therefore have to perform three changes to your class:</p>
<ul class="simple">
<li><p>add <code class="docutils literal notranslate"><span class="pre">&quot;mean_polarizability&quot;</span></code> to <code class="docutils literal notranslate"><span class="pre">POST_PROCESSING_ATTRIBUTES</span></code></p></li>
<li><p>define the <code class="docutils literal notranslate"><span class="pre">mean_polarizability</span></code> attribute as a property (hint: use <code class="docutils literal notranslate"><span class="pre">pol_tensor</span></code> as a template).</p></li>
<li><p>compute the mean polarizabilty in the <code class="docutils literal notranslate"><span class="pre">post_proc</span></code> method (hint: the sum of the diagonal elements of a tensor can be easily computed with numpy: simply use <code class="docutils literal notranslate"><span class="pre">np.trace()</span></code>) and set the <code class="docutils literal notranslate"><span class="pre">mean_polarizability</span></code> attribute via its private counterpart (hint: again, use what is done for <code class="docutils literal notranslate"><span class="pre">pol_tensor</span></code> as a template).</p></li>
</ul>
<p>Once you are happy with your changes, run the whole notebook (click on “Restart Kernel and run all cells” under the “Kernel” tab). You should see that you did not need to modify any cell above to run the tests below. This is a reason why it is interesting to work with classes.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pt_wf_z</span><span class="o">.</span><span class="n">mean_polarizability</span><span class="p">,</span> <span class="mf">12.25712</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">pt_wf_x</span><span class="o">.</span><span class="n">mean_polarizability</span> <span class="o">==</span> <span class="n">pt_wf_y</span><span class="o">.</span><span class="n">mean_polarizability</span> <span class="o">==</span> <span class="n">pt_wf_z</span><span class="o">.</span><span class="n">mean_polarizability</span>
</pre></div>
</div>
</div>
<ul>
<li><p class="rubric" id="further-step-optional">Further step (optional)</p>
</li>
</ul>
<p>You could add the possibility to perform two BigDFT calculations per space coordinates in order to get more accurate results, while removing the reference job without any electric field. This means that six jobs must be run instead of four: two per space coordinate - one with a positive electric field amplitude, the other with a negative one (the run directory in that case must end by <code class="docutils literal notranslate"><span class="pre">x-</span></code> if the electric field is along the <span class="math notranslate nohighlight">\(x\)</span> direction). This is especially relevant when the system
under consideration has no dipole: BigDFT would still find a residual dipole, that might be large enough to give messy results (depending on the required accuracy).</p>
<p>This exercise is optional as it might be a bit tedious for beginners. The main difficulty is to keep the ability of running only four jobs to get the polarizability tensor and the mean polarizability: you will have to add an argument <code class="docutils literal notranslate"><span class="pre">order</span></code> to the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method and make sure it triggers to correct behavior:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">order=1</span></code>, then four jobs should be performed,</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">order=2</span></code>, then six jobs should be performed.</p></li>
</ul>
<p>This means you must make sure that the initialization of the queue depends on that parameter, ans so must be the computation of the polarizability tensor at the post-processing level.</p>
<p>For those interested in doing it, you may want to use the same scheme as above: first use the Workflow class to set up the workflow using six different calculations before actually implementing that into the <code class="docutils literal notranslate"><span class="pre">PolTensor</span></code> class. You might even want to translate the workflow with six jobs to a new class deriving from <code class="docutils literal notranslate"><span class="pre">AbstractWorkflow</span></code>before actually modifying the <code class="docutils literal notranslate"><span class="pre">PolTensor</span></code> class. This should allow you to see which part of the code you have to modify, and to do it in a minimal fashion.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Solution_03.html" class="btn btn-neutral float-right" title="Solution" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../exercise_03.html" class="btn btn-neutral float-left" title="Exercise 3" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Maxime Moriniere, Olivier Malenfant-Thuot

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>